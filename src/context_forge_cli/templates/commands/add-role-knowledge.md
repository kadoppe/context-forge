---
description: 職能（ロール）ごとの知見をClaude Codeプラグインとして追加・更新する
---

# ロール知見プラグイン生成コマンド

このコマンドは、チームの職能（ロール）ごとの知見をClaude Codeプラグインとして対話的に作成・更新します。

## 実行前の準備

最新のClaude Code公式ドキュメントを参照して、プラグイン仕様に準拠したファイルを生成します。

以下のドキュメントをWebFetchで取得してください（取得失敗時は警告を表示して続行）:

1. https://code.claude.com/docs/en/plugins - プラグイン構造
2. https://code.claude.com/docs/en/sub-agents - Sub Agent仕様
3. https://code.claude.com/docs/en/skills - Skill仕様
4. https://code.claude.com/docs/en/hooks-guide - Hook仕様

**重要**: ドキュメント取得に失敗した場合は、以下の警告を表示して続行してください:
> ⚠️ 公式ドキュメントの取得に失敗しました。キャッシュまたは内蔵の仕様に基づいて続行します。

---

## Phase 1: ロールの選択

まず、`.claude/plugins/` ディレクトリをスキャンして既存のロールプラグインを検索してください。
context-forge で生成したプラグインは `context-forge.role-{role-name}` という命名規則に従います。

### 既存プラグインがある場合

以下の形式で一覧を表示:

```
## ロールの選択

以下の既存ロールが見つかりました:

| # | ロール名 | 説明 | 知見数 |
|---|----------|------|--------|
| 1 | {role-name} | {description} | {count} |

選択肢:
- 番号を入力: 既存ロールに知見を追加
- "new": 新規ロールを作成
- "cancel": キャンセル
```

### 既存プラグインがない場合

新規ロール作成フロー（Phase 2）に進みます。

---

## Phase 2: 新規ロールの作成

### ロール名の入力

ユーザーにロール名を尋ねてください:

```
## 新規ロールの作成

### ロール名
ロールの識別名を入力してください（例: frontend-engineer, devops-lead）

Format: 小文字英数字とハイフンのみ (最大64文字)
```

**バリデーション**:
- パターン: `^[a-z0-9-]+$`
- 最大長: 64文字
- 無効な場合はエラーを表示して再入力を促す

### ロールの説明

```
### ロールの説明
このロールの役割と専門領域を簡潔に説明してください。

例: "フロントエンド開発のベストプラクティスとReact/TypeScriptの知見を持つ"
```

---

## Phase 3: 知見の入力

```
## 知見の追加

追加したい知見やスキルを説明してください。

例:
- "コードレビューで確認すべきチェックリスト"
- "設計ドキュメントを自動生成する"
- "セキュリティ観点でコードを自律的にレビューする"
- "コミット前にリンターを実行してチェックする"

複数の知見を追加する場合は、1つずつ処理します。
```

---

## Phase 4: 知見タイプの判定

ユーザーの入力を分析し、最適な実装タイプを判定してください。

### タイプ判定ガイドライン

| パターン | 推奨タイプ | 理由 |
|---------|-----------|------|
| 参照情報、チェックリスト、ガイドライン、ベストプラクティス | **Skill** | Claudeが必要時に自動参照 |
| ワークフロー自動化、ファイル生成、定型作業 | **Command** | ユーザーが明示的に呼び出し |
| 自律的な分析、レビュー、判断が必要なタスク | **Sub Agent** | 複雑なタスクを自律遂行 |
| イベントトリガー、検証、ガード処理 | **Hook** | 特定タイミングで自動実行 |

### 判定結果の表示

```
## 知見タイプの判定

入力: "{user-input}"

**推奨タイプ**: {recommended-type}
**理由**: {reason}

| タイプ | 説明 | この知見に適している理由 |
|--------|------|------------------------|
| A: Skill | 参照情報として自動活用 | {reason-if-applicable} |
| B: Command | スラッシュコマンドで実行 | {reason-if-applicable} |
| C: Sub Agent | 自律的なタスク遂行 | {reason-if-applicable} |
| D: Hook | イベント駆動で自動実行 | {reason-if-applicable} |

推奨を採用する場合は "yes"、変更する場合はA-Dを入力してください。
```

### 判定に自信がない場合

複数のタイプが適切な可能性がある場合は、ユーザーに選択を促してください。

---

## Phase 4.5: トリガー表現の入力（Skill/SubAgent のみ）

**Skill または SubAgent を選択した場合**、description に含めるトリガー表現を入力してもらいます。

```
## トリガー表現の入力

この {knowledge-type} を自動発動させるためのトリガー表現を入力してください。

**最低3つ以上の表現パターンを入力してください。**

Claude Code はこれらの表現を検出すると、この {knowledge-type} を自動的に参照・使用します。

### 入力のコツ

- ユーザーが実際に使いそうな言葉・フレーズを入力
- 同じ意味でも異なる言い回しをカバー
- 短いフレーズと長めの表現を混ぜる

### 例（PRレビュー支援の場合）

- PRをレビューして
- プルリクを確認
- コードレビュー
- 差分を見て
- レビューコメント

カンマ区切りまたは1行1パターンで入力してください:
```

**バリデーション:**
- 最低3つのパターンが必要
- 3つ未満の場合はエラーを表示:
  ```
  ⚠️ トリガー表現は最低3つ必要です（現在: {count}個）。
  追加のパターンを入力してください。
  ```

**入力されたトリガー表現は以下で使用されます:**
1. **Phase 5**: Skill/SubAgent の description に含める
2. **Phase 7.3**: 発動ルールの生成に使用

---

## Phase 5: ファイル生成

選択されたタイプに応じて、適切なファイルを生成します。

### ディレクトリ構造

プラグインは `.claude/plugins/context-forge.role-{role-name}/` に生成します。

```
.claude/plugins/context-forge.role-{role-name}/
├── .claude-plugin/
│   └── plugin.json
├── commands/
│   └── {knowledge-item}.md
├── agents/
│   └── {knowledge-item}.md
├── skills/
│   └── {knowledge-item}/
│       └── SKILL.md
└── hooks/
    └── hooks.json
```

### plugin.json テンプレート

```json
{
  "name": "context-forge.role-{role-name}",
  "description": "{role-description}",
  "version": "{{VERSION}}",
  "author": {
    "name": "Generated by context-forge"
  }
}
```

### Skill ファイルテンプレート

**重要**: description には **3つ以上のトリガー表現パターン** を含めてください。
これにより Claude Code が適切なタイミングで Skill を参照できるようになります。

```markdown
---
name: {knowledge-name}
description: >
  {description}。
  ユーザーが「{trigger-pattern-1}」「{trigger-pattern-2}」「{trigger-pattern-3}」について
  質問・相談した場合に参照すること。
---

{content}
```

**description の生成ルール:**
1. 知見の概要説明（1-2文）
2. トリガー表現パターン（最低3つ）を含める
3. 「について質問・相談した場合に参照すること」で締める

**例:**
```yaml
description: >
  React/TypeScript のベストプラクティスとコーディング規約。
  ユーザーが「Reactのベストプラクティス」「コンポーネントの書き方」「TypeScriptの型定義」
  「フロントエンドの設計」について質問・相談した場合に参照すること。
```

### Command ファイルテンプレート

```markdown
---
description: {description}
---

{content}
```

### Sub Agent ファイルテンプレート

**必須セクション構造**:

生成するSubAgentは以下の構造を**必ず**含めてください：

1. **Frontmatter** (YAML形式) - **description に3つ以上のトリガー表現を含める**
2. **タイトル** (`# {Agent Name}`)
3. **概要説明** (1-2文)
4. **実行手順** (`## 実行手順`) - 番号付きサブセクション
5. **トラブルシューティング** (`## トラブルシューティング`) - 最低1項目
6. **注意事項** (`## 注意事項`) - 最低1項目

**重要**: description には **3つ以上のトリガー表現パターン** を含めてください。
これにより Claude Code が適切なタイミングで SubAgent を Task ツールで呼び出せるようになります。

```markdown
---
name: {knowledge-name}
description: >
  {description}。
  ユーザーが「{trigger-pattern-1}」「{trigger-pattern-2}」「{trigger-pattern-3}」と言った場合に
  このSubAgentを使用すること。
tools: Bash, Read, Write, Edit, Grep, Glob
model: sonnet
---

# {Agent Name}

{概要説明 - このAgentが何をするのか1-2文で説明}

## 実行手順

### 1. {ステップ1のタイトル}

{説明}

### 2. {ステップ2のタイトル}

{説明}

## トラブルシューティング

### コマンドが失敗する場合

1. エラーメッセージを確認する
2. 必要な権限があるか確認する
3. 環境変数が正しく設定されているか確認する

### {追加の問題があれば記載}

## 注意事項

- **ユーザー確認**: 修正を行う前に、必ずユーザーに確認を取ること
- **`git add -A` 禁止**: 必ず修正ファイルを個別に指定すること
- **変更確認**: プッシュ前に `git diff --staged` で変更内容を確認すること
- {追加の注意事項があれば記載}
```

#### Sub Agent 品質ルール

生成するSubAgentファイルは以下のルールに**必ず**従ってください：

##### 1. プレースホルダー禁止

コマンド例やコードブロック内に以下のプレースホルダー構文を**残さないでください**：

- ❌ `<run-id>`, `<file-path>`, `<branch-name>` などの山括弧形式
- ❌ `{owner}/{repo}`, `{pr_number}` などの波括弧形式

代わりに、**動的に値を取得するコマンド**を使用してください：

```bash
# ❌ 禁止: プレースホルダー
gh run view <run-id> --log-failed
gh api repos/{owner}/{repo}/pulls/{pr_number}

# ✅ 推奨: 動的取得
RUN_ID=$(gh run list --limit 1 --json databaseId -q '.[0].databaseId')
gh run view "$RUN_ID" --log-failed

REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner')
PR_NUMBER=$(gh pr view --json number -q '.number')
gh api "repos/${REPO}/pulls/${PR_NUMBER}"
```

**許容されるパターン**:
- `${VAR_NAME}` - シェル変数展開
- `$(command)` - コマンド置換

##### 2. Bashコマンドのルール

SubAgentに含めるbashコマンドは以下のルールに従ってください：

**必須: 変数のクォーティング**
```bash
# ❌ 禁止: クォートなし（スペースを含むパスで失敗）
git add $FILE_PATH
command $VAR

# ✅ 必須: ダブルクォートで囲む
git add "$FILE_PATH"
command "$VAR"
```

**必須: 変数キャッシュ**
```bash
# ❌ 禁止: 同じコマンドを複数回実行
gh api repos/$(gh repo view --json nameWithOwner -q '.nameWithOwner')/pulls
gh api repos/$(gh repo view --json nameWithOwner -q '.nameWithOwner')/issues

# ✅ 必須: 変数にキャッシュして再利用
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner')
gh api "repos/${REPO}/pulls"
gh api "repos/${REPO}/issues"
```

**必須: エラーハンドリング**
```bash
# ❌ 禁止: エラー時の考慮なし
RUN_ID=$(gh run list ...)
gh run view "$RUN_ID"

# ✅ 必須: 変数が空でないことを確認
RUN_ID=$(gh run list --limit 1 --json databaseId -q '.[0].databaseId')
if [ -n "$RUN_ID" ]; then
  gh run view "$RUN_ID" --log-failed
else
  echo "No failed runs found"
fi
```

##### 3. Git操作のルール

SubAgentに含めるgit操作は以下のルールに従ってください：

**禁止: 全ファイルステージング**
```bash
# ❌ 禁止: 意図しないファイルがコミットされる危険性
git add -A
git add .
git add --all

# ✅ 必須: 修正したファイルを個別に指定
git add path/to/modified-file1.md
git add path/to/modified-file2.md
```

**必須: コミット前の確認**
```bash
# ✅ 必須: 変更内容を確認してからコミット
git diff --staged  # ステージされた変更を確認
git status         # ステータスを確認
```

**推奨: プッシュ前の同期**
```bash
# ✅ 推奨: リモートとの同期でコンフリクトを防ぐ
git pull --rebase
git log --oneline -3  # 最近のコミットを確認
```

#### ベストプラクティス参照集

以下は、SubAgentで使用する一般的なパターンの良い例・悪い例です。生成時の参考にしてください。

##### Bashコマンドの良い例・悪い例

**変数キャッシュの完全な例**:
```bash
# ❌ 悪い例: API呼び出しが重複
echo "PR: $(gh pr view --json number -q '.number')"
echo "Title: $(gh pr view --json title -q '.title')"
echo "Author: $(gh pr view --json author -q '.author.login')"

# ✅ 良い例: 一度の呼び出しで複数フィールドを取得
PR_INFO=$(gh pr view --json number,title,author)
PR_NUMBER=$(echo "$PR_INFO" | jq -r '.number')
PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
PR_AUTHOR=$(echo "$PR_INFO" | jq -r '.author.login')
echo "PR: $PR_NUMBER, Title: $PR_TITLE, Author: $PR_AUTHOR"
```

**エラーハンドリングの完全な例**:
```bash
# ❌ 悪い例: エラー時に不正な動作
FAILED_RUN=$(gh run list --status failure --limit 1 --json databaseId -q '.[0].databaseId')
gh run view "$FAILED_RUN" --log-failed  # FAILED_RUN が空の場合エラー

# ✅ 良い例: 条件分岐で安全に処理
FAILED_RUN=$(gh run list --status failure --limit 1 --json databaseId -q '.[0].databaseId')
if [ -n "$FAILED_RUN" ]; then
  echo "失敗したRunを確認します: $FAILED_RUN"
  gh run view "$FAILED_RUN" --log-failed
else
  echo "失敗したRunは見つかりませんでした"
fi
```

##### Git操作の良い例・悪い例

**安全なコミットフローの完全な例**:
```bash
# ❌ 悪い例: 確認なしで全ファイルをコミット
git add -A
git commit -m "Update files"
git push

# ✅ 良い例: 確認を挟んで安全にコミット
# 1. 変更状態を確認
git status

# 2. リモートと同期
git pull --rebase

# 3. 個別にファイルをステージ
git add "src/components/Button.tsx"
git add "src/styles/button.css"

# 4. ステージした内容を確認
git diff --staged

# 5. コミット
git commit -m "feat: Update Button component styles"

# 6. プッシュ前に再確認
git log --oneline -3
git push
```

##### API呼び出しのベストプラクティス（gh コマンド）

**GitHub API の良い例・悪い例**:
```bash
# ❌ 悪い例: プレースホルダーを使用
gh api repos/{owner}/{repo}/pulls/{number}/reviews

# ✅ 良い例: 動的に値を取得
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner')
PR_NUMBER=$(gh pr view --json number -q '.number')
gh api "repos/${REPO}/pulls/${PR_NUMBER}/reviews"
```

**複雑なAPIクエリの例**:
```bash
# PRのレビューコメントを取得
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner')
PR_NUMBER=$(gh pr view --json number -q '.number')

# レビューコメントを取得してパース
COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" \
  --jq '.[] | {path: .path, line: .line, body: .body}')

if [ -n "$COMMENTS" ]; then
  echo "レビューコメント:"
  echo "$COMMENTS" | jq -r '"- \(.path):\(.line): \(.body)"'
else
  echo "レビューコメントはありません"
fi
```

### Hook 設定 (hooks.json)

```json
{
  "hooks": {
    "{event-type}": [
      {
        "matcher": "{tool-name}",
        "hooks": [
          {
            "type": "command",
            "command": "{script-path}"
          }
        ]
      }
    ]
  }
}
```

---

## Phase 5.5: 品質チェック（Sub Agent のみ）

**Sub Agent を生成した場合**、ファイル保存前に以下の品質チェックを実行してください。

### チェック項目

| # | チェック項目 | 自動修正 | 対応方法 |
|---|-------------|---------|---------|
| 1 | プレースホルダー構文 (`<xxx>`, `{xxx}`) がないか | Yes | 動的コマンドに置換 |
| 2 | 変数が適切にクォートされているか | Yes | `"$VAR"` 形式に修正 |
| 3 | `git add -A` や `git add .` を使用していないか | No | 警告を表示（どのファイルを指定すべきか文脈依存のため） |
| 4 | トラブルシューティングセクションがあるか | Yes | テンプレートから追加 |
| 5 | 注意事項セクションがあるか | Yes | テンプレートから追加 |
| 6 | bashコマンドにエラーハンドリングがあるか | No | 警告を表示（適切なパターンは文脈依存のため） |

### 実行手順

1. **生成したファイルを読み込む**
2. **各チェック項目を検証**
3. **自動修正可能な項目**: 問題を自動修正する
4. **自動修正不可能な項目**: 以下の形式で警告を表示

### 自動修正ロジック

#### プレースホルダーの自動修正
```bash
# 検出パターン: <run-id>, {owner}/{repo} など
# 修正: 動的取得コマンドに置換

# Before
gh run view <run-id>

# After
RUN_ID=$(gh run list --limit 1 --json databaseId -q '.[0].databaseId')
gh run view "$RUN_ID"
```

#### 変数クォーティングの自動修正
```bash
# Before
git add $FILE

# After
git add "$FILE"
```

### 警告表示フォーマット

自動修正できない問題（git add -A、エラーハンドリング不足）がある場合は、以下の形式で警告を表示してください：

```
⚠️ 品質チェック警告

以下の項目は自動修正できませんでした。手動で確認してください:

| # | 項目 | 場所 | 推奨対応 |
|---|------|------|---------|
| 1 | 危険なgit操作 | 行 XX | `git add -A` を個別ファイル指定に変更 |
| 2 | エラーハンドリング不足 | 行 XX | if文で変数チェックを追加 |

続行しますか？ (yes/no)
```

### 自動修正できない項目のガイダンス

#### なぜ `git add -A` は自動修正できないのか

`git add -A` をどのファイルに置き換えるべきかは、SubAgentの実行コンテキスト（どのファイルを修正したか）に依存するため、自動的に判断できません。

**手動修正の手順:**
1. SubAgentが修正するファイルを特定する
2. `git add -A` を `git add "specific/file/path.md"` に置き換える
3. 複数ファイルの場合は個別に `git add` を記述する

#### なぜエラーハンドリングは自動修正できないのか

適切なエラーハンドリングパターンは、コマンドの目的と期待される動作に依存するため、自動的に判断できません。

**手動修正の手順:**
1. 変数が空になる可能性があるコマンドを特定する
2. 以下のテンプレートを参考にエラーハンドリングを追加する

```bash
# エラーハンドリングテンプレート
RESULT=$(some_command)
if [ -n "$RESULT" ]; then
  # 正常時の処理
  echo "Success: $RESULT"
else
  # エラー時の処理
  echo "Error: No result found"
  # 必要に応じて早期リターンやフォールバック処理
fi
```

---

## Phase 6: 継続確認

```
## 知見を追加しました

作成したファイル:
- {created-file-path}

次のアクション:
- "add": さらに知見を追加
- "done": 完了してプラグインを確定
- "cancel": 変更を破棄
```

- "add" の場合: Phase 3 に戻る
- "done" の場合: Phase 7 に進む
- "cancel" の場合: 作成したファイルを削除して終了

---

## Phase 7: 完了とプラグイン有効化

### 7.1: marketplace.json の作成・更新

ローカルマーケットプレイスにプラグインを登録するため、`.claude/plugins/.claude-plugin/marketplace.json` を作成・更新します。

1. `.claude/plugins/.claude-plugin/` ディレクトリを作成（存在しない場合）
2. `.claude/plugins/.claude-plugin/marketplace.json` を読み込む（存在しない場合は新規作成）
3. 以下の形式でプラグインを登録:

**新規作成の場合:**
```json
{
  "name": "local",
  "owner": {
    "name": "context-forge"
  },
  "plugins": [
    {
      "name": "context-forge.role-{role-name}",
      "source": "./context-forge.role-{role-name}",
      "description": "{role-description}",
      "version": "{{VERSION}}"
    }
  ]
}
```

**既存ファイルがある場合:**
- `plugins` 配列に新しいプラグインエントリを追加
- 同名のプラグインが既に存在する場合は更新（上書き）

### 7.2: settings.json への登録

プラグインを有効化するため、`.claude/settings.json` に自動登録します。

1. `.claude/settings.json` を読み込む（存在しない場合は新規作成）
2. 以下の設定を追加・マージ:

```json
{
  "extraKnownMarketplaces": {
    "local": {
      "source": {
        "source": "directory",
        "path": "./.claude/plugins"
      }
    }
  },
  "enabledPlugins": {
    "context-forge.role-{role-name}@local": true
  }
}
```

3. 既存の設定がある場合はマージして保存

**重要**:
- `extraKnownMarketplaces.local` はローカルプラグインのマーケットプレイス定義です
- 既存の `enabledPlugins` 設定を上書きせず、新しいエントリを追加してください
- 既に `extraKnownMarketplaces.local` が存在する場合は追加不要です

### 7.3: 発動ルールの追加（Skill/SubAgent のみ）

**Skill または SubAgent を追加した場合**、以下の手順で発動ルールを `.claude/context-forge.md` に追加します。

#### 7.3.1: context-forge.md の存在確認

1. `.claude/context-forge.md` が存在するか確認
2. 存在しない場合は、以下のテンプレートで作成:

```markdown
# context-forge 設定

このファイルは context-forge によって自動生成されます。
手動で編集した内容は、`add-role-knowledge` コマンド実行時に上書きされる可能性があります。

## Skill/SubAgent 発動ルール

以下のルールに従って、適切な Skill または SubAgent を使用してください。

```

#### 7.3.2: 発動ルールの生成

追加した Skill/SubAgent に対して、以下の形式で発動ルールを生成します:

**ルール形式テンプレート:**

```markdown
### {role-name} ロール

- ユーザーが「{trigger-pattern-1}」「{trigger-pattern-2}」「{trigger-pattern-3}」と言った場合、
  必ず {tool-type} ツールで `{knowledge-name}` {knowledge-type} を使用すること
```

**パラメータ説明:**

| パラメータ | 説明 | 例 |
|-----------|------|-----|
| `{role-name}` | ロール名 | `software-engineer` |
| `{trigger-pattern-N}` | トリガー表現（最低3つ） | `PRをレビューして`, `プルリクを確認`, `コードレビュー` |
| `{tool-type}` | Skill の場合は空欄、SubAgent の場合は `Task` | `Task` |
| `{knowledge-name}` | 知見の名前 | `pr-review-assistant` |
| `{knowledge-type}` | `Skill` または `SubAgent` | `SubAgent` |

**例:**

SubAgent の場合:
```markdown
### software-engineer ロール

- ユーザーが「PRをレビューして」「プルリクを確認して」「コードレビュー」「差分を見て」と言った場合、
  必ず Task ツールで `pr-review-assistant` SubAgent を使用すること
```

Skill の場合:
```markdown
### frontend-engineer ロール

- ユーザーが「Reactのベストプラクティス」「コンポーネントの書き方」「フロントエンドの設計」について質問した場合、
  `react-best-practices` Skill を参照すること
```

#### 7.3.3: トリガー表現の入力

ユーザーに発動トリガーとなる表現パターンを入力してもらいます:

```
## 発動トリガーの設定

追加した {knowledge-type} を自動発動させるための表現パターンを入力してください。

**最低3つ以上の表現パターンを入力してください。**

これらの表現を使ってユーザーが依頼した際に、この {knowledge-type} が自動的に呼び出されます。

例（PRレビュー支援の場合）:
- PRをレビューして
- プルリクを確認
- コードレビュー
- 差分を見て

カンマ区切りまたは1行1パターンで入力:
```

**バリデーション:**
- 最低3つのパターンが必要
- 3つ未満の場合はエラーを表示して再入力を促す

#### 7.3.4: ロールセクションの追加/更新

1. `.claude/context-forge.md` を読み込む
2. `### {role-name} ロール` セクションが存在するか確認
3. **存在しない場合**: 新しいロールセクションを追加
4. **存在する場合**: 既存セクションに新しいルールを追記

**追記例:**

```markdown
## Skill/SubAgent 発動ルール

### software-engineer ロール

- ユーザーが「PRをレビューして」「プルリクを確認して」「コードレビュー」と言った場合、
  必ず Task ツールで `pr-review-assistant` SubAgent を使用すること

- ユーザーが「設計ドキュメント」「ADR」「アーキテクチャ」について質問した場合、
  `architecture-guidelines` Skill を参照すること
```

### 7.4: 完了メッセージ

```
## プラグイン生成完了

### 作成されたプラグイン

**ロール**: {role-name}
**場所**: .claude/plugins/context-forge.role-{role-name}/

**構成**:
{tree-structure}

### マーケットプレイス登録

`.claude/plugins/.claude-plugin/marketplace.json` にプラグインを登録しました。

### プラグイン有効化

`.claude/settings.json` に以下を追加しました:
```json
{
  "extraKnownMarketplaces": {
    "local": {
      "source": {
        "source": "directory",
        "path": "./.claude/plugins"
      }
    }
  },
  "enabledPlugins": {
    "context-forge.role-{role-name}@local": true
  }
}
```

### 発動ルール追加（Skill/SubAgent の場合）

`.claude/context-forge.md` に以下の発動ルールを追加しました:

```markdown
{generated-activation-rule}
```

**トリガー表現:**
- {trigger-pattern-1}
- {trigger-pattern-2}
- {trigger-pattern-3}
- ...

### 次のステップ

1. Claude Codeを再起動してプラグインをロード
2. プラグインが認識されると、追加した知見が自動的に利用可能になります
3. Skillは関連するタスクで自動参照されます
4. Commandは `/context-forge.role-{role-name}.{command-name}` で実行できます
5. Sub Agentは Task ツールで呼び出せます
6. **発動ルールにより、トリガー表現を使うと自動的に適切な Skill/SubAgent が呼び出されます**
```

---

## エラーハンドリング

| エラー | 対応 |
|--------|------|
| ロール名が無効 | 形式エラーを表示し再入力を促す |
| 既存プラグインと競合 | 更新フローへ誘導 |
| ドキュメント取得失敗 | 警告表示 + 内蔵仕様で続行 |
| ファイル書き込み失敗 | エラー表示 + 権限確認ヒント |
| キャンセル | 作成中のファイルを削除して終了 |

---

## 既存プラグインへの知見追加

既存のロールを選択した場合:

1. 既存の plugin.json を読み込み
2. 既存の知見一覧を表示
3. Phase 3 から開始
4. hooks.json が既に存在する場合は追記（上書きしない）
